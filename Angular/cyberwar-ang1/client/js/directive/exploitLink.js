angular.module('CyberWar')
.directive('exploitLink', function(GameState, GameUtil) {
  function link($scope, element, attrs) {
    var myExploitLine, alongLineTriangle, againstLineTriangle, theirExploitLine;

    GameState.addListener(onGameStateChanged);

    // ----------------------------------------------------------------------------
    $scope.$on('$destroy', function() {
      GameState.removeListener(onGameStateChanged);
      myExploitLine.remove();
      alongLineTriangle.remove();
      againstLineTriangle.remove();
      theirExploitLine.remove();
    });

    // ----------------------------------------------------------------------------
    function onGameStateChanged() {
      // Make sure our exploit link is our color
      myExploitLine.stroke(GameUtil.getColor(GameState.currentPlayerData.color));
      alongLineTriangle.fill(GameUtil.getColor(GameState.currentPlayerData.color));
      againstLineTriangle.fill(GameUtil.getColor(GameState.currentPlayerData.color));

      // Update our exploit links based on what we know
      myExploitLine.visible(isLineLinked(GameState.currentPlayerData.exploitLinks));
      alongLineTriangle.visible(isDirectionLinked($scope.nodeA, $scope.nodeB, GameState.currentPlayerData.exploitLinks));
      againstLineTriangle.visible(isDirectionLinked($scope.nodeB, $scope.nodeA, GameState.currentPlayerData.exploitLinks));
      theirExploitLine.visible(isLineLinked(GameState.currentPlayerData.scannedExploitLinks));
    }

    // ----------------------------------------------------------------------------
    var createKonvaObjects = function(nodeA, nodeB) {
      // Get the positions of our endpoints
      var nodeAPosition = GameUtil.getHexPosition(nodeA.color, nodeA.index);
      var nodeBPosition = GameUtil.getHexPosition(nodeB.color, nodeB.index);

      // Special case positioning for links from a base
      if (nodeA.index == 0) {
        nodeAPosition = getBasePosition(nodeAPosition, nodeBPosition);
      }
      else if (nodeB.index == 0) {
        nodeBPosition = getBasePosition(nodeBPosition, nodeAPosition);
      }

      // How far over our exploit links are
      var exploitLinkOffset = 12;

      // Find our perpendicular unit vector to our line
      var perpendicular = getPerpendicularVector(nodeAPosition.x, nodeBPosition.x, nodeAPosition.y, nodeBPosition.y, exploitLinkOffset);

      var group = new Konva.Group();

      // Create the Konva line for if we have exploit links
      var myExploitLineStartPointX = nodeAPosition.x + perpendicular.x;
      var myExploitLineStartPointY = nodeAPosition.y + perpendicular.y;
      var myExploitLineEndPointX = nodeBPosition.x + perpendicular.x;
      var myExploitLineEndPointY = nodeBPosition.y + perpendicular.y;
      myExploitLine = new Konva.Line({
        points: [
          myExploitLineStartPointX,
          myExploitLineStartPointY,
          myExploitLineEndPointX,
          myExploitLineEndPointY
        ],
        stroke: 'black',
        strokeWidth: exploitLinksStroke,
        lineCap: 'square',
        lineJoin: 'square',
        dash: [
          exploitLineDashWidth,
          exploitLineDashGap
        ],
        id: nodeA.color + nodeA.index + ' to ' + nodeB.color + nodeB.index + ' My Exploit Link'
      });

      // Create the triangles for our exploit link directions
      var firstTriangleLineRatio = 4 / 11; // How far along the exploit line the first triangle lies (arbitrarily picked because it looks good)
      var secondTriangleLineRatio = 1 - firstTriangleLineRatio; // How far along the exploit line the second triangle lies
      var triangleRotation = Math.atan2(myExploitLineEndPointY - myExploitLineStartPointY, myExploitLineEndPointX - myExploitLineStartPointX) * 180 / Math.PI;
      alongLineTriangle = new Konva.RegularPolygon({
        x: firstTriangleLineRatio * (myExploitLineStartPointX) + secondTriangleLineRatio * (myExploitLineEndPointX),
        y: firstTriangleLineRatio * (myExploitLineStartPointY) + secondTriangleLineRatio * (myExploitLineEndPointY),
        rotation: triangleRotation - 30,
        sides: 3,
        radius: 8,
        fill: 'black',
        stroke: 'black',
        strokeWidth: dashStroke,
        id: nodeA.color + nodeA.index + ' to ' + nodeB.color + nodeB.index + ' My Exploit Link Direction'
      });

      againstLineTriangle = new Konva.RegularPolygon({
        x: secondTriangleLineRatio * (myExploitLineStartPointX) + firstTriangleLineRatio * (myExploitLineEndPointX),
        y: secondTriangleLineRatio * (myExploitLineStartPointY) + firstTriangleLineRatio * (myExploitLineEndPointY),
        rotation: triangleRotation + 30,
        sides: 3,
        radius: 8,
        fill: 'black',
        stroke: 'black',
        strokeWidth: dashStroke,
        id: nodeA.color + nodeB.index + ' to ' + nodeA.color + nodeB.index + ' My Exploit Link Direction'
      });

      // Create the Konva line for if others have exploit links
      theirExploitLine = new Konva.Line({
        points: [
          nodeAPosition.x - perpendicular.x,
          nodeAPosition.y - perpendicular.y,
          nodeBPosition.x - perpendicular.x,
          nodeBPosition.y - perpendicular.y
        ],
        // rotation
        stroke: 'black',
        strokeWidth: exploitLinksStroke,
        lineCap: 'square',
        lineJoin: 'square',
        dash: [
          exploitLineDashWidth,
          exploitLineDashGap
        ],
        id: nodeA.color + nodeA.index + ' to ' + nodeB.color + nodeB.index + ' Their Exploit Link'
      });

      group.add(myExploitLine, alongLineTriangle, againstLineTriangle, theirExploitLine);
      linksGroup.add(group);

      group.on('mouseover', function () {
        document.body.style.cursor = 'pointer';
      });
      group.on('mouseout', function () {
        document.body.style.cursor = 'default';
      });
      group.on('click', function () {
        if ($scope.callbackFn) {
          $scope.$apply($scope.callbackFn({ nodeA: $scope.nodeA, nodeB: $scope.nodeB }));
        }
      });
    }

    // ----------------------------------------------------------------------------
    var isLineLinked = function(linksList) {
      return GameUtil.List.areLocationsLinked($scope.nodeA, $scope.nodeB, linksList);
    }

    // ----------------------------------------------------------------------------
    var isDirectionLinked = function(nodeA, nodeB, linksList) {
      return GameUtil.List.isLinkInLinkList({ nodeA: nodeA, nodeB: nodeB }, linksList);
    }

    // ----------------------------------------------------------------------------
    // Get the position of our point for the base represented by the given points
    var getBasePosition = function(basePoints, nodePoint) {
      // The ratios for how close we want the resulting point to each point of the base's hex
      var firstBaseNodeOffset = 1 / 6; // Arbitrarily picked because it looks good
      var secondBaseNodeOffset = 1 - firstBaseNodeOffset;
      var firstBasePosition = { x: basePoints.x1, y: basePoints.y1 };
      var secondBasePosition = { x: basePoints.x2, y: basePoints.y2 };
      var distanceFromFirstBaseToNode = getDistance(firstBasePosition, nodePoint);
      var distanceFromSecondBaseToNode = getDistance(secondBasePosition, nodePoint);
      // If the node is closer to the first point, we want our base position closer to the first point
      if (distanceFromFirstBaseToNode < distanceFromSecondBaseToNode) {
        return {
          x: secondBasePosition.x * firstBaseNodeOffset + firstBasePosition.x * secondBaseNodeOffset,
          y: secondBasePosition.y * firstBaseNodeOffset + firstBasePosition.y * secondBaseNodeOffset
        };
      }
      // Otherwise, we want the base position closer to the second point
      return {
        x: firstBasePosition.x * firstBaseNodeOffset + secondBasePosition.x * secondBaseNodeOffset,
        y: firstBasePosition.y * firstBaseNodeOffset + secondBasePosition.y * secondBaseNodeOffset
      };
    }

    // ----------------------------------------------------------------------------
    // Get the distance between two points
    var getDistance = function(pointA, pointB) {
      var x = pointA.x - pointB.x;
      var y = pointA.y - pointB.y;
      return Math.sqrt(x * x + y * y);
    }

    // ----------------------------------------------------------------------------
    // Stolen from here: https://stackoverflow.com/questions/133897/how-do-you-find-a-point-at-a-given-perpendicular-distance-from-a-line
    var getPerpendicularVector = function(x1, x2, y1, y2, length) {
      var dx = x1 - x2;
      var dy = y1 - y2;
      var dist = Math.sqrt(dx * dx + dy * dy);
      dx /= dist;
      dy /= dist;
      return { x: dy * length, y: -dx * length };
    }

    createKonvaObjects($scope.nodeA, $scope.nodeB);
    onGameStateChanged();
  }
  return {
    link: link,
    restrict: 'E',
    scope: {
      callbackFn: '&',
      nodeA: '=',
      nodeB: '='
    },
  }
});
